
/*
Password-Based AES Encryption Code
Coded by : Abdelqader Okasha
As part of Image Stagenography project by: Obada Hattab, Mohammad Majdi and Abdelqader Okasha

Note on Password Hashing and key derivation:
This code implementes the Password-Based Key Derivation Function 2 (PBKDF2), as specified in RFC 2898. - Pseudorandom function used : HMAC-SHA-1
We used a Standalone implementation of HMAC-SHA-1 developed by Bob Liu "Akagi201", GitHub library name: "hmac-sha1". Copyright (c) 2014 Bob Liu

This is an open source project, code can be copied, used or modified provided the below copyright line is left within the body of the code
Copyright (C) 2018 DoodAbooD | Abdelqader Okasha
*/

#include <cstdlib>
#include <iostream>
#include <iomanip>
#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <time.h>
#include <fstream>
#include <sys/stat.h>
#include "AES.h"


#ifdef __cplusplus
extern "C"
{
#endif

#include "hmac.h"" 
	//Implementation by Bob Liu (Originally written in C)
#ifdef __cplusplus
}
#endif

using namespace std;



typedef std::basic_string<unsigned char> ustring;
#define fori(x) for (int i = 0; i < x ; i++)
#define forj(x) for (int j = 0; j < x ; j++)


const unsigned char AES::AESIrrPoly = 0b00011011; //AES Standard irreducible Polynomial ( X^8 + X^4 + X^3 + X + 1)

//s-box and inverse s-box lookup tables
const unsigned char AES::s[256] =
{
	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
};
const unsigned  char AES::inv_s[256] =
{
	0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
	0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
	0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
	0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
	0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
	0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
	0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
	0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
	0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
	0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
	0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
	0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
	0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
	0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
	0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
};

const unsigned char AES::rcon[15] =
{
	0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d 
};

//Polynomial multiply by 2, 3, 9, 11, 13 and 14 look-up tables
const unsigned char AES::Mult_2[256] =
{
	0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
	0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
	0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
	0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
	0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
	0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
	0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
	0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
	0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
	0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
	0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
	0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
	0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
	0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
	0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
	0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
};

const unsigned char AES::Mult_3[256] =
{
	0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
	0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
	0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
	0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
	0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
	0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
	0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
	0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
	0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
	0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
	0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
	0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
	0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
	0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
	0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
	0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
};


const unsigned char AES::Mult_9[256] =
{
	0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
	0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
	0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
	0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
	0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
	0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
	0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
	0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
	0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
	0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
	0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
	0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
	0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
	0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
	0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
	0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46
};

const unsigned char AES::Mult_11[256] =
{
	0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
	0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
	0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
	0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
	0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
	0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
	0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
	0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
	0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
	0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
	0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
	0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
	0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
	0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
	0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
	0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3
};
const unsigned char AES::Mult_13[256] =
{
	0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
	0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
	0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
	0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
	0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
	0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
	0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
	0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
	0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
	0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
	0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
	0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
	0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
	0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
	0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
	0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97
};
const unsigned char AES::Mult_14[256] =
{
	0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
	0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
	0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
	0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
	0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
	0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
	0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
	0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
	0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
	0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
	0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
	0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
	0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
	0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
	0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
	0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d
};

//****************** Helper Functions *************************
int chhex(char ch) //convert single hex to char
{
	if (isdigit(ch))
		return ch - '0';
	if (tolower(ch) >= 'a' && tolower(ch) <= 'f')
		return ch - 'a' + 10;
	return -1;
}

bool HexToChar(unsigned char *dest, const char *source, int bytes_n) { //convert hex stream to char stream
	fori(bytes_n) {
		if (chhex(source[i * 2]) == -1) return false;
		dest[i] = int(16 * chhex(source[i * 2]) + chhex(source[(i * 2) + 1]));
	}
	return true;
}


#define PBSTR "||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"	//Progress Indicator Character
#define PBWIDTH 60																//Progress Bar Width

void AES::printProgress(double percentage) {
	int val = (int)(percentage * 100);
	int lpad = (int)(percentage * PBWIDTH);
	int rpad = PBWIDTH - lpad;
	printf("\r%3d%% [%.*s%*s]", val, lpad, PBSTR, rpad, "");
	fflush(stdout);
}


//***************************************************************

void AES::Substitue(unsigned char *A) {
	fori(16) A[i] = s[A[i]];
}

void AES::InvSubstitue(unsigned char *B) {
	fori(16) B[i] = inv_s[B[i]];
}

void AES::ShiftRow(unsigned char *B) {
	unsigned char M[16] =
	{
		B[0], B[5], B[10], B[15],
		B[4], B[9], B[14], B[3],
		B[8], B[13], B[2], B[7],
		B[12], B[1], B[6], B[11],
	};
	fori(16) B[i] = M[i];
}

void AES::InvShiftRow(unsigned char *B) {
	unsigned char M[16] =
	{
		B[0], B[13], B[10], B[7],
		B[4], B[1], B[14], B[11],
		B[8], B[5], B[2], B[15],
		B[12], B[9], B[6], B[3],
	};
	fori(16) B[i] = M[i];
}



void AES::MixColumn(unsigned char *B) {
	unsigned char C[16] =
	{
		Mult_2[B[0]] ^ Mult_3[B[1]] ^ B[2] ^ B[3],
		B[0] ^ Mult_2[B[1]] ^ Mult_3[B[2]] ^ B[3],
		B[0] ^ B[1] ^ Mult_2[B[2]] ^ Mult_3[B[3]],
		Mult_3[B[0]] ^ B[1] ^ B[2] ^ Mult_2[B[3]],

		Mult_2[B[4]] ^ Mult_3[B[5]] ^ B[6] ^ B[7],
		B[4] ^ Mult_2[B[5]] ^ Mult_3[B[6]] ^ B[7],
		B[4] ^ B[5] ^ Mult_2[B[6]] ^ Mult_3[B[7]],
		Mult_3[B[4]] ^ B[5] ^ B[6] ^ Mult_2[B[7]],

		Mult_2[B[8]] ^ Mult_3[B[9]] ^ B[10] ^ B[11],
		B[8] ^ Mult_2[B[9]] ^ Mult_3[B[10]] ^ B[11],
		B[8] ^ B[9] ^ Mult_2[B[10]] ^ Mult_3[B[11]],
		Mult_3[B[8]] ^ B[9] ^ B[10] ^ Mult_2[B[11]],

		Mult_2[B[12]] ^ Mult_3[B[13]] ^ B[14] ^ B[15],
		B[12] ^ Mult_2[B[13]] ^ Mult_3[B[14]] ^ B[15],
		B[12] ^ B[13] ^ Mult_2[B[14]] ^ Mult_3[B[15]],
		Mult_3[B[12]] ^ B[13] ^ B[14] ^ Mult_2[B[15]],

	};

	fori(16) B[i] = C[i];
	
}
void AES::InvMixColumn(unsigned char *C) {
	unsigned char B[16] =
	{
		Mult_14[C[0]] ^ Mult_11[C[1]] ^ Mult_13[C[2]] ^ Mult_9[C[3]],
		Mult_9[C[0]] ^ Mult_14[C[1]] ^ Mult_11[C[2]] ^ Mult_13[C[3]],
		Mult_13[C[0]] ^ Mult_9[C[1]] ^ Mult_14[C[2]] ^ Mult_11[C[3]],
		Mult_11[C[0]] ^ Mult_13[C[1]] ^ Mult_9[C[2]] ^ Mult_14[C[3]],

		Mult_14[C[4]] ^ Mult_11[C[5]] ^ Mult_13[C[6]] ^ Mult_9[C[7]],
		Mult_9[C[4]] ^ Mult_14[C[5]] ^ Mult_11[C[6]] ^ Mult_13[C[7]],
		Mult_13[C[4]] ^ Mult_9[C[5]] ^ Mult_14[C[6]] ^ Mult_11[C[7]],
		Mult_11[C[4]] ^ Mult_13[C[5]] ^ Mult_9[C[6]] ^ Mult_14[C[7]],

		Mult_14[C[8]] ^ Mult_11[C[9]] ^ Mult_13[C[10]] ^ Mult_9[C[11]],
		Mult_9[C[8]] ^ Mult_14[C[9]] ^ Mult_11[C[10]] ^ Mult_13[C[11]],
		Mult_13[C[8]] ^ Mult_9[C[9]] ^ Mult_14[C[10]] ^ Mult_11[C[11]],
		Mult_11[C[8]] ^ Mult_13[C[9]] ^ Mult_9[C[10]] ^ Mult_14[C[11]],

		Mult_14[C[12]] ^ Mult_11[C[13]] ^ Mult_13[C[14]] ^ Mult_9[C[15]],
		Mult_9[C[12]] ^ Mult_14[C[13]] ^ Mult_11[C[14]] ^ Mult_13[C[15]],
		Mult_13[C[12]] ^ Mult_9[C[13]] ^ Mult_14[C[14]] ^ Mult_11[C[15]],
		Mult_11[C[12]] ^ Mult_13[C[13]] ^ Mult_9[C[14]] ^ Mult_14[C[15]],
	};

	fori(16) C[i] = B[i];

}

void AES::KeyAddition(unsigned char *P, unsigned char *k) {
	fori(16) P[i] = P[i] ^ k[i];

}

void AES::ExpandKey(unsigned char *K, unsigned char *keys, int mode) { // mode 0 : 128-bit key | 1 : 192-bit key | 2 : 256-bit key

	//First key is original supplied key
	fori(16 + (8 * mode)) keys[i] = K[i];

	float modemultiplier = (mode / 2.0) + 1.0;
	int round = 1;
	int CurrentRoundBase;
	unsigned char temp[4];

	//Key Schedule 10/12/14 rounds loop
	while (round != (11 - ceil(1.5 * mode))) {
		CurrentRoundBase = round * modemultiplier * 16;
		//applying "g" function to last 4 bytes and placing them in temp
		temp[0] = rcon[round] ^ s[keys[CurrentRoundBase - 3]];
		temp[1] = s[keys[CurrentRoundBase - 2]];
		temp[2] = s[keys[CurrentRoundBase - 1]];
		temp[3] = s[keys[CurrentRoundBase - 4]];

		//loop on 16 bytes of the current round key, each one takes value as (temp XOR previousKey), and updates temp with itself.
		fori(16 * modemultiplier) {
			if ((mode == 1) && (round == 8) && (i == 16)) break; //end limit for 192-bit key
			if ((mode == 2) && (round == 7) && (i == 16)) break; //end limit for 256-bit key
			temp[i % 4] = keys[CurrentRoundBase + i] = keys[CurrentRoundBase - int(16.0 * modemultiplier) + i] ^ temp[i % 4];
			if ((mode == 2) && (i == 15)) forj(4) temp[j] = s[temp[j]];  //s-boxing at mid of round for 256-bit 
		}
		round++;
	}

}

//Basic Encryption block (128 bits)
void AES::Encrypt128(unsigned char *P, unsigned char *KeySched, unsigned char *output, int mode) { // mode is 0 : 128-bit key size | 1 : 192-bit key size | 2 : 256-bit key size
	
	unsigned char C[] =
	{	P[0],P[1],P[2],P[3],
		P[4],P[5],P[6],P[7],
		P[8],P[9],P[10],P[11],
		P[12],P[13],P[14],P[15] };

	// First Key addition
	KeyAddition(C, KeySched);

	// 9 or 11 or 13 rounds depending on key size (mode)
	fori(9 + (2 * mode)) {
		Substitue(C);
		ShiftRow(C);
		MixColumn(C);
		KeyAddition(C, &KeySched[(i + 1) * 16]);
	}

	//last round
	Substitue(C);
	ShiftRow(C);
	KeyAddition(C, &KeySched[160 + (mode * 32)]);

	fori(16) output[i] = C[i];
}

//Basic Decryption block (128 bits)
void AES::Decrypt128(unsigned char *C, unsigned char *KeySched, unsigned char *output, int mode) {

	unsigned char P[] =
	{	C[0],C[1],C[2],C[3],
		C[4],C[5],C[6],C[7],
		C[8],C[9],C[10],C[11],
		C[12],C[13],C[14],C[15] };

	//last round inverse
	KeyAddition(P, &KeySched[160 + (mode * 32)]);
	InvShiftRow(P);
	InvSubstitue(P);

	//9 rounds inverse
	int midrounds = 9 + (2 * mode);
	fori(midrounds) {

		KeyAddition(P, &KeySched[(midrounds - i) * 16]);
		InvMixColumn(P);
		InvShiftRow(P);
		InvSubstitue(P);
	}

	// First Key addition inverse
	KeyAddition(P, KeySched);

	fori(16) output[i] = P[i];
}


//Main Encrption function (CBC, password based)
void AES::Encrypt(ustring Text, ustring Pass, ustring *CipherText, int mode, bool ShowProgress = false) { // mode 0 : 128-bit key | 1 : 192-bit key | 2 : 256-bit key

	CipherText->clear();
	int LengthOfString = Text.length();

	//Padding Text (Method: CMS)
	int PaddingBytes = 16 - (LengthOfString % 16);
	fori(PaddingBytes) Text.push_back(PaddingBytes); //CMS (Cryptographic Message Syntax). This pads Text with the same value as the number of padding bytes.

	//Generating Random block (RGB) (16 bytes) to be used for Salt and Initial Vector for CBC Mode
	unsigned char RGB[16];
	srand(time(NULL));
	fori(16) RGB[i] = (rand() % 91) + 32; //ASCII Range 32-122


	//Salt is assigned the even position bytes of RGB vector XORed with the Odd bytes (8 bytes derived out of the 16 bytes of RGB)
	unsigned char salt[8] = { RGB[0] ^ RGB[1], RGB[2] ^ RGB[3], RGB[4] ^ RGB[5], RGB[6] ^ RGB[7], RGB[8] ^ RGB[9], RGB[10] ^ RGB[11], RGB[12] ^ RGB[13], RGB[14] ^ RGB[15] };
	//Adding salt to the password
	while (Pass.length() < 30) {
		int i = 0;
		Pass.push_back(salt[i++]);
		if (i == 8) i = 0;
	}

	//-----------PBKDF2  (2000 iterations) to derive key from password---------------------
	uint8_t U[20];
	uint8_t key[30]; //Key
	fori(30) key[i] = Pass[i]; //Assigning salted password to key
	uint8_t data[12]; //Data, takes salt as value[0-7] and "0001" as [8-11]
	fori(8) data[i] = salt[i];
	data[8] = 0; // Concatenating Integer '1' (0001) to data vector
	data[9] = 0;
	data[10] = 0;
	data[11] = 1;

#ifdef _WIN64  //Necessary To compile for both 64 or 32 enviornments
	unsigned __int64 len = 20;
#else
	unsigned int len = 20;
#endif

	uint8_t T_1[20];
	uint8_t T_2[20];
	//T_1
	//first round (Using Salt as data and Pass as Key)
	hmac_sha1(key, 30, data, 12, U, &len);
	memcpy(T_1, U, 20);
	//1999 rounds (Using Previous Generated value as data and Pass as key)
	fori(1999) {
		hmac_sha1(key, 30, U, 20, U, &len);
		forj(20) T_1[j] ^= U[j];
	}
	//T_2 (if 192/256 mode)
	if (mode != 0) {
		data[10]++; // Concatenating Integer '2' (0010) to data vector
		data[11]--;
		//first round (Using Salt as data and Pass as Key)
		hmac_sha1(key, 30, data, 12, U, &len);
		memcpy(T_2, U, 20);
		//1999 rounds (Using Previous Generated value as data and Pass as key)
		fori(1999) {
			hmac_sha1(key, 30, U, 20, U, &len);
			forj(20) T_1[j] ^= U[j];
		}
	}
	//Assigning result to the AES key variable K
	unsigned char *K = NULL;
	switch (mode) {
	case 0: // 128-bit key
		K = new unsigned char[16];
		memcpy(K, T_1, 16);
		break;

	case 1: // 192-bit key
		K = new unsigned char[24];
		memcpy(K, T_1, 16);
		memcpy(K + 16, T_2, 8);
		break;

	case 2: // 256-bit key
		K = new unsigned char[32];
		memcpy(K, T_1, 16);
		memcpy(K + 16, T_2, 16);
		break;
	}
	//------------------------------------------------------------------------------------ 


	//Expand key to produce Key Schedule
	unsigned char *KeySched = new unsigned char[176 + (mode * 32)];
	ExpandKey(K, KeySched, mode);



	//State Division
	int NumberOfStates = (Text.length() / 16);
	unsigned char **state = new unsigned char*[NumberOfStates];
	fori(NumberOfStates) state[i] = new unsigned char[16];
	ustring::iterator itr = Text.begin();
	fori(NumberOfStates) forj(16) state[i][j] = *itr++;

	//CBC Scheme (Using RGB as Initial Vector)
	unsigned char OutputBuffer[16];
	unsigned char XORVECTOR[16];
	memcpy(XORVECTOR, RGB, 16);
	fori(NumberOfStates) {
		forj(16) state[i][j] = state[i][j] ^ XORVECTOR[j];
		Encrypt128(state[i], KeySched, OutputBuffer, mode);
		forj(16) {
			XORVECTOR[j] = OutputBuffer[j];
			CipherText->push_back(OutputBuffer[j]);
		}
		if (ShowProgress && (i % 10000 == 0)) printProgress((double)(i + 1) / (double)NumberOfStates);
	}
	if (ShowProgress) printProgress(1);
	fori(16) CipherText->push_back(RGB[i]); //Adding RGB block at the end of cipher text


	////************ Optional: Writes Key and Initial vector to external file (REDUCES SECURITY) **************
	//ofstream myfile;
	//myfile.open("KEY & IV.txt");
	//myfile << "KEY:\n";
	//fori(16 + (8 * mode)) myfile << unsigned int(K[i]) << " ";
	//myfile << "\nInitialVector:\n";
	//fori(16) myfile << unsigned int(RGB[i]) << " ";
	//myfile << "\n";
	//myfile.close();


	//Deleting Heap mem variables
	fori(NumberOfStates) delete[] state[i];
	delete[] state;
	delete[] K;
	delete[] KeySched;
}


bool AES::Decrypt(ustring CipherText, ustring Pass, ustring *Text, int mode, bool ShowProgress = false) {
	Text->clear();
	//Reading RGB vector
	unsigned char RGB[16];
	ustring::iterator eitr = CipherText.end();
	eitr -= 16;
	fori(16) RGB[i] = *eitr++;
	fori(16) CipherText.pop_back();

	//Calculate Salt
	unsigned char salt[8] = { RGB[0] ^ RGB[1], RGB[2] ^ RGB[3], RGB[4] ^ RGB[5], RGB[6] ^ RGB[7], RGB[8] ^ RGB[9], RGB[10] ^ RGB[11], RGB[12] ^ RGB[13], RGB[14] ^ RGB[15] };

	//Adding salt to the password
	while (Pass.length() < 30) {
		int i = 0;
		Pass.push_back(salt[i++]);
		if (i == 8) i = 0;
	}

	//-----------PBKDF2  (2000 iterations) to derive key from password---------------------
	uint8_t U[20];
	uint8_t key[30]; //Key
	fori(30) key[i] = Pass[i]; //Assigning salted password to key
	uint8_t data[12]; //Data, takes salt as value[0-7] and "0001" as [8-11]
	fori(8) data[i] = salt[i];
	data[8] = 0; // Concatenating Integer '1' (0001) to data vector
	data[9] = 0;
	data[10] = 0;
	data[11] = 1;

#ifdef _WIN64  //Necessary To compile for both 64 or 32 enviornments
	unsigned __int64 len = 20;
#else
	unsigned int len = 20;
#endif

	uint8_t T_1[20];
	uint8_t T_2[20];
	//T_1
	//first round (Using Salt as data and Pass as Key)
	hmac_sha1(key, 30, data, 12, U, &len);
	memcpy(T_1, U, 20);
	//1999 rounds (Using Previous Generated value as data and Pass as key)
	fori(1999) {
		hmac_sha1(key, 30, U, 20, U, &len);
		forj(20) T_1[j] ^= U[j];
	}
	//T_2 (if 192/256 mode)
	if (mode != 0) {
		data[10]++; // Concatenating Integer '2' (0010) to data vector
		data[11]--;
		//first round (Using Salt as data and Pass as Key)
		hmac_sha1(key, 30, data, 12, U, &len);
		memcpy(T_2, U, 20);
		//1999 rounds (Using Previous Generated value as data and Pass as key)
		fori(1999) {
			hmac_sha1(key, 30, U, 20, U, &len);
			forj(20) T_1[j] ^= U[j];
		}
	}
	//Assigning result to the AES key variable K
	unsigned char *K = NULL;
	switch (mode) {
	case 0: // 128-bit key
		K = new unsigned char[16];
		memcpy(K, T_1, 16);
		break;

	case 1: // 192-bit key
		K = new unsigned char[24];
		memcpy(K, T_1, 16);
		memcpy(K + 16, T_2, 8);
		break;

	case 2: // 256-bit key
		K = new unsigned char[32];
		memcpy(K, T_1, 16);
		memcpy(K + 16, T_2, 16);
		break;
	}
	//------------------------------------------------------------------------------------ 


	//Expand key to produce Key Schedule
	unsigned char *KeySched = new unsigned char[176 + (mode * 32)];
	ExpandKey(K, KeySched, mode);



	//State Division
	int LengthOfCipher = CipherText.length();
	int NumberOfStates = (LengthOfCipher / 16);
	unsigned char **state = new unsigned char*[NumberOfStates];
	fori(NumberOfStates) state[i] = new unsigned char[16];
	ustring::iterator itr = CipherText.begin();
	fori(NumberOfStates) forj(16) state[i][j] = *itr++;


	//CBC Scheme (Using RGB as Initial Vector)
	unsigned char OutputBuffer[16];
	unsigned char XORVECTOR[16];
	memcpy(XORVECTOR, RGB, 16);
	fori(NumberOfStates) {
		Decrypt128(state[i], KeySched, OutputBuffer, mode);
		forj(16) {
			OutputBuffer[j] = OutputBuffer[j] ^ XORVECTOR[j];
			Text->push_back(OutputBuffer[j]);
			XORVECTOR[j] = state[i][j];
			if (ShowProgress && (i % 10000 == 0)) printProgress((double)(i + 1) / (double)NumberOfStates);
		}
	}
	if (ShowProgress) printProgress(1);

	//Unpadding Text
	int PaddingBytes = Text->back();
	if (PaddingBytes > 16) return false;
	fori(PaddingBytes) Text->pop_back();

	//Deleting Heap mem variables
	fori(NumberOfStates) delete state[i];
	delete[]state;
	return true;

}


//Functions used for testing purposes
void AES::EncryptTest(ustring Text, ustring *CipherText, int mode) {
	CipherText->clear();

	unsigned char RGB[16] =
	{
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	};


	unsigned char K[16] =
	{
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	};

	//Expand key to produce Key Schedule
	unsigned char KeySched[176];
	ExpandKey(K, KeySched, mode);


	unsigned char OutputBuffer[16];

	//State Division
	int NumberOfStates = (Text.length() / 16);
	unsigned char **state = new unsigned char*[NumberOfStates];
	fori(NumberOfStates) state[i] = new unsigned char[16];
	ustring::iterator itr = Text.begin();
	fori(NumberOfStates) forj(16) state[i][j] = *itr++;

	//CBC Scheme (Using RGB as Initial Vector)
	unsigned char XORVECTOR[16];
	memcpy(XORVECTOR, RGB, 16);
	fori(NumberOfStates) {
		forj(16) state[i][j] = state[i][j] ^ XORVECTOR[j];
		Encrypt128(state[i], KeySched, OutputBuffer, mode);
		forj(16) {
			XORVECTOR[j] = OutputBuffer[j];
			CipherText->push_back(OutputBuffer[j]);
		}
	}

	ofstream myfile;
	myfile.open("KEY & IV.txt");
	myfile << "KEY:\n";
	fori(16) myfile << unsigned int(K[i]) << " ";
	myfile << "\nInitialVector:\n";
	fori(16) myfile << unsigned int(RGB[i]) << " ";
	myfile << "\n";
	myfile.close();


	//Deleting Heap mem variables
	fori(NumberOfStates) delete state[i];
	delete[]state;
}
bool AES::DecryptTest(ustring CipherText, ustring Key, ustring IV, ustring *PlainText, int mode) {
	PlainText->clear();


	//Expand key to produce Key Schedule
	unsigned char KeySched[176];
	ExpandKey(&Key[0], KeySched, mode);

	unsigned char OutputBuffer[16];

	//State Division
	int LengthOfCipher = CipherText.length();
	int NumberOfStates = (LengthOfCipher / 16);
	unsigned char **state = new unsigned char*[NumberOfStates];
	fori(NumberOfStates) state[i] = new unsigned char[16];
	ustring::iterator itr = CipherText.begin();
	fori(NumberOfStates) forj(16) state[i][j] = *itr++;


	//CBC Scheme (Using IV as Initial Vector)
	unsigned char XORVECTOR[16];
	memcpy(XORVECTOR, &IV[0], 16);
	fori(NumberOfStates) {
		Decrypt128(state[i], KeySched, OutputBuffer, mode);
		forj(16) {
			OutputBuffer[j] = OutputBuffer[j] ^ XORVECTOR[j];
			PlainText->push_back(OutputBuffer[j]);
			XORVECTOR[j] = state[i][j];
		}
	}

	//Unpadding Text
	int PaddingBytes = PlainText->back();
	if (PaddingBytes > 16) return false;
	fori(PaddingBytes) PlainText->pop_back();

	//Deleting Heap mem variables
	fori(NumberOfStates) delete state[i];
	delete[]state;
	return true;

}

//*************************************** MAIN FUNCTION BODY *******************************************

int main(int argc, char *argv[]) {


	//*******************************************************************************************
	//******************************* TESTING : AES VALIDATION **********************************
	//*******************************************************************************************

	

	//unsigned char test[16] =
	//{
	//	0,0,0,0,
	//	0,0,0,0,
	//	0,0,0,0,
	//	0,0,0,0
	//};
	//unsigned char out[16];
	//unsigned char in[16];
	//unsigned char sched[240];
	//ofstream myfile;
	//myfile.open("result2.txt");
	//AES::ExpandKey(out, sched, 2);
	//int equal = 1;
	//srand(time(NULL));
	//char buffer[30];


	//fori(100000) {
	//	myfile << "ITR " << i << "\t";
	//	cout << "ITR " << i << "\t";
	//	srand(rand());
	//	forj(16) test[j] = rand() % 256;
	//	cout << "TEMPLATE: ";  forj(16) printf("%X ", test[j]); printf("\t | \t"); 
	//	myfile << "TEMPLATE: "; forj(16) {sprintf_s(buffer, "%X ", test[j]); myfile << buffer;} myfile << "\t | \t";
	//	AES::Encrypt128(test, sched, out, 2);
	//	AES::Decrypt128(out, sched, in, 2);
	//	cout << "RESPONSE: "; forj(16) printf("%X ", in[j]);
	//	myfile << "RESPONSE: "; forj(16) { sprintf_s(buffer, "%X ", in[j]); myfile << buffer; }
	//	forj(16) if (test[j] != in[j]) {printf("FAIL at %d,%d \n", &i, &j); system("PAUSE"); }
	//	cout << "      MATCH" << endl; myfile << "  MATCH" << endl;
	//	AES::printProgress(i / 100000.0);
	//}



	//AES::printProgress(1);
	//cout << "DONE" << endl;
	//system("PAUSE");





	//*******************************************************************************************
	//********************************* TEXT ENCRYPTION *****************************************
	//*******************************************************************************************

	//if (argv[1][0] == '?') {
	//	cout << endl << "AES ENCRYPTION EXECUTABLE" << endl;
	//	cout << endl << "COPYRIGHTS (C) ABDELQADER OKASHA | DOODABOOD " << endl;
	//	cout << "USAGE: 'ENCRYPT' <PLAINTEXT> <PASSWORD> <MODE (0:128, 1:192, 2:256)>";
	//	return 0;
	//}

	//if (argc < 4) {
	//	cout << "ERROR: TOO FEW ARGUMENTS USAGE: 'ENCRYPT' <PLAINTEXT> <PASSWORD> <MODE (0:128, 1:192, 2:256)>";
	//	return 0;
	//}
	//int mode;
	//string text = "";
	//string pass = "";
	//int i = 1;
	//forj(argc-3) {
	//	text.append(argv[i++]);
	//	text.push_back(' ');
	//}
	//text.pop_back();
	//pass.append(argv[i]);
	//mode = argv[i + 1][0] - '0' ;
	//if ((mode < 0) || (mode > 2)) {
	//	cout << "ERROR: INCORRECT MODE ENTERED: " << argv[i+1][0] << ", POSSIBLE VALUES FOR MODE ARE 0, 1 or 2";
	//	return 0;
	//}
	//ustring utext, upass, ucipher;
	//string::iterator itr = text.begin();
	//while(itr!=text.cend()) utext.push_back(*itr++);
	//itr = pass.begin();
	//while (itr != pass.cend()) upass.push_back(*itr++);
	//AES::Encrypt(utext, upass, &ucipher, mode);

	////print out encrypted cipher in hex
	//fori(ucipher.length()) 	cout << setfill('0') << setw(2) << hex << (int)ucipher[i];
	//return 0;



	//*******************************************************************************************
	//********************************** TEXT DECRYPTION ****************************************
	//*******************************************************************************************


	//if (argv[1][0] == '?') {
	//	cout << endl << "AES DECRYPTION EXECUTABLE" << endl;
	//	cout << endl << "COPYRIGHTS (C) ABDELQADER OKASHA | DOODABOOD " << endl;
	//	cout << "USAGE: DECRYPT <CIPHERTEXT(IN HEX FORMAT)> <PASSWORD> <MODE (0:128, 1:192, 2:256)>";
	//	return 0;
	//}
	//
	//if (argc != 4) {
	//	cout << "ERROR: TOO MANY/FEW ARGUMENTS, USAGE: DECRYPT <CIPHERTEXT(IN HEX FORMAT)> <PASSWORD> <MODE (0:128, 1:192, 2:256)>";
	//	return 0;
	//}

	////Convert hex to characters and assign variables
	//unsigned char *ccipher = new unsigned char[strlen(argv[1]) / 2];
	//if (!HexToChar(ccipher, argv[1], strlen(argv[1]) / 2)) {
	//	cout << "ERROR: INVALID CIPHER INPUT, CIPHER SHOULD BE IN HEX FORM";
	//	return 0;
	//}	
	//ustring ucipher;
	//ucipher.clear();
	//fori(strlen(argv[1]) / 2) ucipher.push_back(ccipher[i]);
	//string pass = argv[2];	
	//int mode = argv[3][0] - '0';
	//ustring  upass, utext;

	//string::iterator itr = pass.begin();
	//while (itr != pass.cend()) upass.push_back(*itr++);
	//if (AES::Decrypt(ucipher, upass, &utext, mode)) {
	//	fori(utext.length()) printf("%c", utext[i]);
	//}
	//else cout << "ERROR: INVALID INPUT / WRONG PASSWORD" << endl;

	//delete ccipher;
	//return 0;




	//*************************************************************************************************
	//*************************************** FILE ENCRYPTION *****************************************
	//*************************************************************************************************


	//if (argc != 5) {
	//	cout << "ERROR: TOO MANY/FEW ARGUMENTS, USAGE: 'FENCRYPT' <EXISTING PLAIN FILEPATH> <NEW CIPHER FILEPATH> <PASSWORD> <ENCRYPTION MODE (0:128, 1:192, 2:256)>";
	//	return 0;
	//}

	//if (argv[1][0] == '?') {
	//	cout << endl << "AES FILE ENCRYPTION EXECUTABLE" << endl;
	//	cout << endl << "COPYRIGHTS (C) ABDELQADER OKASHA | DOODABOOD " << endl;
	//	cout << "USAGE: 'FENCRYPT' <EXISTING PLAIN FILEPATH> <NEW CIPHER FILEPATH> <PASSWORD> <ENCRYPTION MODE (0:128, 1:192, 2:256)>";
	//	return 0;
	//}

	//string filename = argv[1];
	//string pass = argv[3];	
	//int mode = argv[4][0] - '0';


	//if ((mode < 0) || (mode > 2)) {
	//	cout << "ERROR: INCORRECT MODE ENTERED: " << mode << ", POSSIBLE VALUES FOR MODE ARE 0, 1 or 2";
	//	return 0;
	//}


	//
	//fstream PlainFile, CipherFile;
	//PlainFile.open(argv[1], ios::in | ios::binary);
	//if (!PlainFile.is_open()) { cout << "ERROR: CANNOT READ FROM FILE ???????" << endl; return 0; }


	////Reading file size
	//PlainFile.seekg(0, ios::end);
	//int size = PlainFile.tellg();
	//PlainFile.seekg(0);
	//if (size > 157286408) {
	//	cout << "ERROR: FILE TOO LARGE (MAXIMUN SIZE: 150MB)" << endl;
	//	return 0;
	//}


	//CipherFile.open(argv[2], ios::out | ios::binary);
	//if (!CipherFile.is_open()) { cout << "ERROR: CANNOT WRITE TO FILE ???????" << endl; return 0; }


	//ustring utext, upass, ucipher;
	//string::iterator itr = pass.begin();
	//while (itr != pass.cend()) upass.push_back(*itr++);

	////Reading from input file
	//unsigned char *stream = new unsigned char[size];
	//PlainFile.read((char *)stream, size);
	//fori(size) utext.push_back(stream[i]);
	//itr = filename.begin(); 
	//// adding "data OK" flag
	//utext.push_back('*');
	//utext.push_back('D');
	//utext.push_back('O');
	//utext.push_back('K');
	//utext.push_back('7');
	//utext.push_back('8');
	//utext.push_back('9');
	//utext.push_back('5');
	////adding file name at end of file
	//while (itr != filename.cend()) utext.push_back(*itr++); 

	//PlainFile.close();


	//cout << "Encrypting ..." << endl;
	////Encryption
	//AES::Encrypt(utext, upass, &ucipher, mode, true);
	//int csize = ucipher.length();
	//unsigned char *cstream = new unsigned char[csize];
	//ustring::iterator uitr = ucipher.begin();
	//fori(csize) cstream[i] = *uitr++;

	////Writing to output file
	//CipherFile.write((char *)cstream, csize);
	//CipherFile.close();
	//cout << endl << "File Successfully Encrypted at '" << argv[2] << "'" << endl;
	//delete[] stream;
	//delete[] cstream;



	//*************************************************************************************************
	//*************************************** FILE DECRYPTION *****************************************
	//*************************************************************************************************



	if (argc != 5) {
		cout << "ERROR: TOO MANY/FEW ARGUMENTS, USAGE: 'FDECRYPT' <EXISTING ENCRYPTED FILEPATH> <DECRYPTION FILE PATH> <PASSWORD> <ENCRYPTION MODE (0:128, 1:192, 2:256)>";
		return 0;
	}

	if (argv[1][0] == '?') {
		cout << endl << "AES FILE DECRYPTION EXECUTABLE" << endl;
		cout << endl << "COPYRIGHTS (C) ABDELQADER OKASHA | DOODABOOD " << endl;
		cout << "USAGE: 'FDECRYPT' <EXISTING ENCRYPTED FILEPATH> <DECRYPTION FILE PATH> <PASSWORD> <ENCRYPTION MODE (0:128, 1:192, 2:256)>";
		return 0;
	}

	string cfilename = argv[1];
	string pass = argv[3];
	int mode = argv[4][0] - '0';


	if ((mode < 0) || (mode > 2)) {
		cout << "ERROR: INCORRECT MODE ENTERED: " << mode << ", POSSIBLE VALUES FOR MODE ARE 0, 1 or 2";
		return 0;
	}



	fstream PlainFile, CipherFile;
	CipherFile.open(argv[1], ios::in | ios::binary);
	if (!CipherFile.is_open()) { cout << "ERROR: CANNOT READ FROM FILE '" << argv[1] << "'" << endl; CipherFile.close(); return 0; }

	//Reading file size
	CipherFile.seekg(0, ios::end);
	int csize = CipherFile.tellg();
	CipherFile.seekg(0);
	if (csize > 157286400) {
		cout << "ERROR: FILE TOO LARGE (MAXIMUN SIZE: 150MB)" << endl;
		return 0;
	}

	PlainFile.open(argv[2], ios::out | ios::binary);
	if (!PlainFile.is_open()) { cout << "ERROR: CANNOT WRITE TO FILE '" << argv[2] << "'" << endl; PlainFile.close(); return 0; }


	ustring utext, upass, ucipher;
	string::iterator itr = pass.begin();
	while (itr != pass.cend()) upass.push_back(*itr++);

	//Reading from input file
	unsigned char *cstream = new unsigned char[csize];
	CipherFile.read((char *)cstream, csize);
	fori(csize) ucipher.push_back(cstream[i]);
	CipherFile.close();


	cout << "Attempting Decryption ..." << endl;

	//Encryption
	AES::Decrypt(ucipher, upass, &utext, mode, true);
	
	//Seeking 'data OK' flag
	ustring::iterator uitr = utext.end();
	while (*uitr != '*') {
		if (uitr == utext.begin()) {
			cout << endl << "ERROR: DECRYPTION FAILED, INCORRECT PASSWORD OR INVALID FILE (COULD BE ENCRYPTED ELSEWHERE)." << endl;
			delete[] cstream;
			PlainFile.close();
			remove(argv[2]); //Delete attempted file
			return 0;
		}
		uitr--; }
	string check;
	fori(7) check.push_back(*++uitr);
	if (check != "DOK7895") {
		cout << "check = " << check << endl;
		cout << endl << "ERROR: DECRYPTION FAILED, INCORRECT PASSWORD OR INVALID FILE (COULD BE ENCRYPTED ELSEWHERE)." << endl;
		delete[] cstream;
		PlainFile.close();
		remove(argv[2]); //Delete attempted file
		return 0;
	}

	//Reading Original File Name
	string originalfilename;
	while (uitr != utext.cend()) originalfilename.push_back(*++uitr);
	fori(originalfilename.length() + 8) utext.pop_back(); //Erasing file name and 'data OK' flag written at end
	

	//Writing to output file
	int size = utext.length();
	unsigned char *stream = new unsigned char[size];
	uitr = utext.begin();
	fori(size) stream[i] = *uitr++;
	PlainFile.write((char *)stream, size);
	PlainFile.close();
	rename(argv[2], originalfilename.c_str());
	remove(argv[1]); //Delete old file
	cout << endl << "File Successfully Decrypted at '" << originalfilename << "'" << endl;

	delete[] stream;
	delete[] cstream;


}

//*************************************************************************************************
